#example
def greet(name):
    print("Hello, {0}!".format(name))
print("What's your name?")
name = raw_input()
greet(name)
def greet(name):
    print("Hello, {0}!".format(name))
print("What's your name?")
name = input()
greet(name)
#ack_c
import serial

#ser = serial.Serial('/dev/cu.usbserial-AL0046V6', 9600)
#ser = serial.Serial('/dev/ttyAMA0', 9600)
ser = serial.Serial('/dev/ttyS0', 9600)
while True:
	try:
		incoming = ser.readline().strip()
		print('COORDINATOR received "%s"' % incoming.decode())
	except KeyboardInterrupt:
		exit()
#ack_r1
import serial

#ser = serial.Serial('/dev/ttyAMA0', 9600)
ser = serial.Serial('/dev/ttyS0', 9600)
while True:
	try:
		incoming = ser.readline().strip()
		print('ROUTER_1 received "%s"' % incoming.decode())
	except KeyboardInterrupt:
		exit()
import serial
#ack_r2
#ser = serial.Serial('/dev/ttyAMA0', 9600)
ser = serial.Serial('/dev/ttyS0', 9600)
while True:
	try:
		incoming = ser.readline().strip()
		print('ROUTER_2 received "%s"' % incoming.decode())
	except KeyboardInterrupt:
		exit()
#address
import sys
from geopy.geocoders import Nominatim
geolocator = Nominatim(user_agent="iot-application")
coordinates = sys.argv[1]
location = geolocator.reverse(coordinates)
print(location.address)
print((location.latitude, location.longitude))
#adxl
import time
from adxl345 import ADXL345

adxl345 = ADXL345()
print("ADXL345 on address 0x%x:" % (adxl345.address))

def runController():
    axes = adxl345.getAxes(True)
    print('x = %.3f y = %.3f z = %.3f' % (axes['x'], axes['y'], axes['z']))

while True:
    runController()
    time.sleep(5)
#auto   
import RPi.GPIO as GPIO
import time

GPIO.setmode(GPIO.BCM)
ldr_threshold = 1000
LDR_PIN = 24
LIGHT_PIN = 18

def readLDR(PIN):
    count = 0
    GPIO.setup(PIN, GPIO.OUT)
    GPIO.output(PIN, False)
    time.sleep(0.1)
    GPIO.setup(PIN, GPIO.IN)
    while (GPIO.input(PIN) == False):
        count = count + 1
    return count

def switchOnLight(PIN):
    GPIO.setup(PIN, GPIO.OUT)
    GPIO.output(PIN, True)

def switchOffLight(PIN):
    GPIO.setup(PIN, GPIO.OUT)
    GPIO.output(PIN, False)

while True:
    try:
        ldr_reading = readLDR(LDR_PIN)
        print(ldr_reading)
        if ldr_reading > ldr_threshold:
            switchOnLight(LIGHT_PIN)
        else:
            switchOffLight(LIGHT_PIN)
        time.sleep(1)
    except KeyboardInterrupt:
        GPIO.cleanup()
        exit()
#print(location.raw)
#blink
import RPi.GPIO as GPIO
from time import sleep

GPIO.setmode(GPIO.BCM)
GPIO.setup(18, GPIO.OUT)

while True:
    try:
        GPIO.output(18, True)
        sleep(1)
        GPIO.output(18, False)
        sleep(1)
    except KeyboardInterrupt:
        GPIO.cleanup()
        exit()
#coordinates
import sys
from geopy.geocoders import Nominatim
geolocator = Nominatim(user_agent="iot-application")
address = sys.argv[1]
location = geolocator.geocode(address)
print(location.address)
print((location.latitude, location.longitude))
#print(location.raw)
#data_example
from datetime import date
now = date.today()
print('Date: ' + now.isoformat())
print('Date: ' + now.strftime('%m-%d-%y'))
print('Day of Week: ' + now.strftime('%A'))
print('Month: ' + now.strftime('%B'))
print('Year: ' + now.strftime('%Y'))
first = date(2020, 8, 31)
last = date(2020, 12, 7)
timediff = now - first
print('{:d} days after the first day of classes'.format(timediff.days))
timediff = last - now
print('{:d} days before the last day of classes'.format(timediff.days))
#hello
import smtplib
from time import sleep
import RPi.GPIO as GPIO
from sys import exit

from_email = 'GMAIL_ADDRESS'
receipients_list = ['RECIPIENT_EMAIL']
cc_list = []
subject = 'Hello'
message = 'Switch pressed on Raspberry Pi'
username = 'GMAIL_USERNAME'
password = 'GOOGLE_APP_PASSWORD'
server = 'smtp.gmail.com:587'

GPIO.setmode(GPIO.BCM)
GPIO.setup(25, GPIO.IN)

def sendmail(from_addr, to_addr_list, cc_addr_list,
             subject, message,
             login, password,
             smtpserver):

    header = 'From: %s \n' % from_addr
    header += 'To: %s \n' % ','.join(to_addr_list)
    header += 'Cc: %s \n' % ','.join(cc_addr_list)
    header += 'Subject: %s \n \n' % subject
    message = header + message

    server = smtplib.SMTP(smtpserver)
    server.starttls()
    server.login(login, password)
    problems = server.sendmail(from_addr, to_addr_list, message)
    server.quit()

while True:
    try:
        if (GPIO.input(25) == True):
            sendmail(from_email, receipients_list,
                     cc_list, subject, message,
                     username, password, server)
        sleep(.01)
    except KeyboardInterrupt:
        GPIO.cleanup()
        exit()
#hello_c        
import serial

#ser = serial.Serial('/dev/cu.usbserial-AL0046V6', 9600)
#ser = serial.Serial('/dev/ttyAMA0', 9600)
ser = serial.Serial('/dev/ttyS0', 9600)
outgoing = b'Hello from COORDINATOR'
print('COORDINATOR sent "%s"' % outgoing.decode())
ser.write('%s\n'.encode() % outgoing)
#hello_c1
import serial

#ser = serial.Serial('/dev/ttyAMA0', 9600)
ser = serial.Serial('/dev/ttyS0', 9600)
outgoing = b'Hello from ROUTER 1'
print('Sent "%s"' % outgoing.decode())
ser.write('%s\n'.encode() % outgoing)
#hello_c2
import serial
#ldrtmp
#ser = serial.Serial('/dev/ttyAMA0', 9600)
ser = serial.Serial('/dev/ttyS0', 9600)
outgoing = b'Hello from ROUTER 2'
print('Sent "%s"' % outgoing.decode())
ser.write('%s\n'.encode() % outgoing)
#julian
from datetime import date
from jdcal import *
now = date.today()
jd = gcal2jd(now.year, now.month, now.day)
print('Calendar Date: {:s}'.format(now.isoformat()))
print('Julian Date: {:0.1f}'.format(jd[0]+jd[1]))
print('Modified Julian Date: {:0.1f}'.format(jd[1]))
#ldr_adc
import spidev
spi=spidev.SpiDev()
spi.open(0,0)
spi.max_speed_hz = 976000
adc=spi.xfer2([1, 8<<4, 0])
print('adc = ', adc)
data=((adc[1]&3)<<8)+adc[2]
print('data = ', data)
spi.close()
#ldr_lux
import sys
import spidev
channel = 0
spi = spidev.SpiDev()
spi.open(0, 0)
spi.max_speed_hz = 976000
adc = spi.xfer2([1, (8 + channel) << 4, 0])
print('adc = ', adc)
data = ((adc[1]&3) << 8) + adc[2]
print('data = ', data)
R = 10
places = 2
volts = (data * 3.3) / 1023
volts = round(volts, places)
print('volts = ', volts)
if volts == 0:
    lux = 0
else:
    lux = 500 * (3.3 - volts) / (R * volts)
print('lux = ', lux)
spi.close()

import spidev
import time
import os

# open(bus, device) : open(X,Y) will open /dev/spidev-X.Y
spi = spidev.SpiDev()
spi.open(0,0)

# Read SPI data from MCP3008, Channel must be an integer 0-7
def ReadADC(ch):
    if ((ch > 7) or (ch < 0)):
       return -1
    adc = spi.xfer2([1,(8+ch)<<4,0])
    data = ((adc[1]&3)<<8) + adc[2]
    return data

# Convert data to voltage level
def ReadVolts(data,deci):
    volts = (data * 3.3) / 1023
    volts = round(volts,deci)
    return volts

# Calculate temperature from TMP36 data
def ConvertTemp(data,deci):
    temp = (data - 0.413) * 100
    temp = round(temp,deci)
    return temp

# Define sensor channels
light_ch = 0
temp_ch  = 1

# Define delay between readings
delay = 3

while True:
    try:
        # Read the light sensor data
        light_data = ReadADC(light_ch)
        light_volts = ReadVolts(light_data,2)

        # Read the temperature sensor data
        temp_data = ReadADC(temp_ch)
        temp_volts = ReadVolts(temp_data,4)
        temp       = ConvertTemp(temp_volts,2)

        # Print out results
        print("Temp  : ",temp_data, " (",temp_volts ,"V) -->",temp,"~C    Light : ",light_data," (",light_volts,"V)")

        # Delay seconds
        time.sleep(delay)

    except KeyboardInterrupt:
        exit()
#led        
from gpiozero import LED
from time import sleep

green = LED(18)

while True:
    try:
        green.on()
        sleep(2)
        green.off()
        sleep(2)
    except KeyboardInterrupt:
        green.close()
        exit()  
#manaul        
from time import sleep
import RPi.GPIO as GPIO

GPIO.setmode(GPIO.BCM)

# Switch Pin
GPIO.setup(25, GPIO.IN)

# LED Pin
GPIO.setup(18, GPIO.OUT)

state = False

def toggleLED(pin):
    global state
    state = not state
    GPIO.output(pin, state)

while True:
    try:
        if(GPIO.input(25) == True):
            toggleLED(18)
        sleep(1)
    except KeyboardInterrupt:
        GPIO.cleanup()
        exit()  
#moon       
from datetime import date, timedelta
from astral import moon
now = date.today()
for i in range(30):
    day = now + timedelta(days=i)
    moon_phase = moon.phase(day)
    print(day.isoformat() + ' Moon Phase: %d' % moon_phase)   
#no2    
import time
import spidev

# Sensor channel on MCP3008
#CO_CHANNEL = 0
NO2_CHANNEL = 1

vin = 5
r0 = 10000
pullup = 10000

# Conversions based on Rs/Ro vs ppm plots of the sensors
#CO_Conversions = [((0, 100), (0, 0.25)), ((100, 133), (0.25, 0.325)),
#    ((133, 167), (0.325, 0.475)), ((167, 200), (0.475, 0.575)),
#    ((200, 233), (0.575, 0.665)), ((233, 267), (0.666, 0.75))]
NO2_Conversions = [((0, 100), (0, 0.25)), ((100, 133), (0.25, 0.325)),
    ((133, 167), (0.325, 0.475)), ((167, 200), (0.475, 0.575)),
    ((200, 233), (0.575, 0.665)), ((233, 267), (0.666, 0.75))]

# Open SPI bus
spi = spidev.SpiDev()
spi.open(0, 0)

# Function to read SPI data from MCP3008 chip
def ReadChannel(channel):
    adc = spi.xfer2([1, (8 + channel) << 4, 0])
    data = ((adc[1] & 3) << 8) + adc[2]
    return data

def get_resistance(channel):
    result = ReadChannel(channel)
    if result == 0:
        resistance = 0
    else:
        resistance = (vin/result -1) * pullup
    return resistance

def converttoppm(rs, conversions):
    rsper = 100 * (float(rs) / r0)
    for a in conversions:
        if a[0][0] >= rsper > a[0][1]:
            mid, hi = rsper - a[0][0], a[0][1] - a[0][0]
            sf = float(mid) / hi
            ppm = sf * (a[1][1] - a[1][0]) + a[1][0]
            return ppm
        return 0

def get_NO2():
    rs = get_resistance(NO2_CHANNEL)
    ppm = converttoppm(rs, NO2_Conversions)
    return ppm

#def get_CO():
#    rs = get_resistance(CO_CHANNEL)
#    ppm = converttoppm(rs, CO_Conversions)
#    return ppm

# Controller main function
def runController():
    NO2_reading = get_NO2()
#    CO_reading = get_CO()
#    print('CO={0:0.5f} ppm  NO2={1:0.5f} ppm'.format(CO_reading, NO2_reading))
    print('NO2={:0.5f} ppm'.format(NO2_reading))

while True:
    runController()
    time.sleep(10)    
#no2co    
import time
import spidev

# Sensor channel on MCP3008
CO_CHANNEL = 0
NO2_CHANNEL = 1

vin = 5
r0 = 10000
pullup = 10000

# Conversions based on Rs/Ro vs ppm plots of the sensors
CO_Conversions = [((0, 100), (0, 0.25)), ((100, 133), (0.25, 0.325)),
    ((133, 167), (0.325, 0.475)), ((167, 200), (0.475, 0.575)),
    ((200, 233), (0.575, 0.665)), ((233, 267), (0.666, 0.75))]
NO2_Conversions = [((0, 100), (0, 0.25)), ((100, 133), (0.25, 0.325)),
    ((133, 167), (0.325, 0.475)), ((167, 200), (0.475, 0.575)),
    ((200, 233), (0.575, 0.665)), ((233, 267), (0.666, 0.75))]

# Open SPI bus
spi = spidev.SpiDev()
spi.open(0, 0)

# Function to read SPI data from MCP3008 chip
def ReadChannel(channel):
    adc = spi.xfer2([1, (8 + channel) << 4, 0])
    data = ((adc[1] & 3) << 8) + adc[2]
    return data

def get_resistance(channel):
    result = ReadChannel(channel)
    if result == 0:
        resistance = 0
    else:
        resistance = (vin/result -1) * pullup
    return resistance

def converttoppm(rs, conversions):
    rsper = 100 * (float(rs) / r0)
    for a in conversions:
        if a[0][0] >= rsper > a[0][1]:
            mid, hi = rsper - a[0][0], a[0][1] - a[0][0]
            sf = float(mid) / hi
            ppm = sf * (a[1][1] - a[1][0]) + a[1][0]
            return ppm
        return 0

def get_NO2():
    rs = get_resistance(NO2_CHANNEL)
    ppm = converttoppm(rs, NO2_Conversions)
    return ppm

def get_CO():
    rs = get_resistance(CO_CHANNEL)
    ppm = converttoppm(rs, CO_Conversions)
    return ppm

# Controller main function
def runController():
    NO2_reading = get_NO2()
    CO_reading = get_CO()
    print('CO={0:0.5f} ppm  NO2={1:0.5f} ppm'.format(CO_reading, NO2_reading))

while True:
    runController()
    time.sleep(10)    
#pyexample    
## @package pyexample
#  Documentation for this module.
#
#  More details.
## Documentation for a function.
#
#  More details.
def func():
    pass
## Documentation for a class.
#
#  More details.
class PyClass:
   
    ## The constructor.
    def __init__(self):
        self._memVar = 0;
   
    ## Documentation for a method.
    #  @param self The object pointer.
    def PyMethod(self):
        pass
     
    ## A class variable.
    classVar = 0;
    ## @var _memVar
    #  a member variable    
#servo1    
import RPi.GPIO as GPIO
import time

P_SERVO = 22 # adapt to your wiring
fPWM = 50  # Hz (not higher with software PWM)
a = 10
b = 2

def setup():
    global pwm
    GPIO.setmode(GPIO.BCM)
    GPIO.setup(P_SERVO, GPIO.OUT)
    pwm = GPIO.PWM(P_SERVO, fPWM)
    pwm.start(0)

def setDirection(direction):
    duty = a / 180 * direction + b
    pwm.ChangeDutyCycle(duty)
    print("direction =", direction, "-> duty =", duty)
    time.sleep(1) # allow to settle
   
print("starting")
setup()
for direction in range(0, 181, 10):
    setDirection(direction)
direction = 0    
setDirection(0)    
GPIO.cleanup() 
print("done")    
#sevomotor
import RPi.GPIO as GPIO
import time

servoPIN = 22
GPIO.setmode(GPIO.BCM)
GPIO.setup(servoPIN, GPIO.OUT)

p = GPIO.PWM(servoPIN, 50) # GPIO 22 for PWM with 50Hz
p.start(2.5) # Initialization
try:
  while True:
    p.ChangeDutyCycle(5)
    time.sleep(0.5)
    p.ChangeDutyCycle(7.5)
    time.sleep(0.5)
    p.ChangeDutyCycle(10)
    time.sleep(0.5)
    p.ChangeDutyCycle(12.5)
    time.sleep(0.5)
    p.ChangeDutyCycle(10)
    time.sleep(0.5)
    p.ChangeDutyCycle(7.5)
    time.sleep(0.5)
    p.ChangeDutyCycle(5)
    time.sleep(0.5)
    p.ChangeDutyCycle(2.5)
    time.sleep(0.5)
except KeyboardInterrupt:
  p.stop()
  GPIO.cleanup()
#socket_client  
import sys
import socket
HOST = sys.argv[1]        # The remote host IP address
PORT = 50007              # The same port as used by the server
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
s.sendall('Hello, world'.encode())
data = s.recv(1024).decode()
s.close()
print('Received', repr(data))  
#socket_server
import socket
HOST = ''                 # Symbolic name meaning all available interfaces
PORT = 50007              # Arbitrary non-privileged port
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((HOST, PORT))
s.listen(1)
conn, addr = s.accept()
print('Connected by', addr)
while 1:
    data = conn.recv(1024)
    if not data: break
    conn.sendall(data)
conn.close()
#soil
import RPi.GPIO as GPIO
import time
import spidev

# Moisture sensor channel on MCP3008
moisture_channel = 0

GPIO.setmode(GPIO.BCM)
TRIGGER_PIN = 18
threshold = 10

# Open SPI bus
spi = spidev.SpiDev()
spi.open(0, 0)

# Function to read SPI data from MCP3008 chip
def ReadChannel(channel):
    adc = spi.xfer2([1, (8+channel) << 4, 0])
    data = ((adc[1] & 3) << 8) + adc[2]
    return data

# Function to read sensor connected to MCP3008
def readMoisture():
    level = ReadChannel(moisture_channel)
    return level

# Controller main function
def runController():
    level = readMoisture()

Check moisture level
    if (level < threshold):
        GPIO.output(TRIGGER_PIN, True)
    else:
        GPIO.output(TRIGGER_PIN, False)

    print("Moisture: %s" % level)

while True:
    runController()
    time.sleep(10)
#sound    
import RPi.GPIO as GPIO
import time

# GPIO SETUP
channel = 17
GPIO.setmode(GPIO.BCM)
GPIO.setup(channel, GPIO.IN)

def callback(channel):
        if GPIO.input(channel):
                print("Sound Detected!")
        else:
                print("Sound Detected!")

GPIO.add_event_detect(channel, GPIO.BOTH, bouncetime=300)  # let us know when the pin goes HIGH or LOW
GPIO.add_event_callback(channel, callback)  # assign function to GPIO PIN, Run function on change

# infinite loop
while True:
        time.sleep(1)   
#student        
def averageGrade(students):
    sum=0.0
    for key in students:
        sum=sum+students[key]['grade']
    average=sum/len(students)
    return average
def printRecords(students):
    print('There are %d students' % (len(students)))
    i=1
    for key in students:
        print('Student %d:' % (i))
        print('Name: ' + students[key]['name'])
        print('Grade: ' + str(students[key]['grade']))
        i=i+1      
#sun        
import sys, pytz
from datetime import date
from astral.geocoder import database, lookup
from astral.sun import sun
city_name = sys.argv[1]
city = lookup(city_name, database())
print('Information for %s/%s\n' % (city.name, city.region))
timezone = city.timezone
print('Timezone: %s' % timezone)
print('Latitude: %.02f; Longitude: %.02f\n' % (city.latitude, city.longitude))
s = sun(city.observer, date=date.today(), tzinfo=pytz.timezone(timezone))
print('Dawn:    %s' % str(s['dawn']))
print('Sunrise: %s' % str(s['sunrise']))
print('Noon:    %s' % str(s['noon']))
print('Sunset:  %s' % str(s['sunset']))
print('Dusk:    %s' % str(s['dusk']))      
#system
import subprocess
import os
def get_ram():
# Returns a tuple (total ram, available ram) in megabytes. See www.linuxatemyram.com
    try:
        s = (subprocess.check_output(['free','-m'])).decode()
        lines = s.split('\n')
        return int(lines[1].split()[1]), int(lines[2].split()[3])
    except:
        return 0

def get_process_count():
# Returns the number of processes
    try:
        s = (subprocess.check_output(['ps','-e'])).decode()
        return len(s.split('\n'))
    except:
        return 0

def get_up_stats():
# Returns a tuple (uptime, 5 min load average)
    try:
        s = (subprocess.check_output(['uptime'])).decode()
        load_split = s.split('load average: ')
        load_five = float(load_split[1].split(',')[1])
        up = load_split[0]
        up_pos = up.rfind(',',0,len(up)-4)
        up = up[:up_pos].split('up ')[1]
        return ( up , load_five )
    except:
        return '' , 0

def get_connections():
# Returns the number of network connections
    try:
        s = (subprocess.check_output(['netstat','-tun'])).decode()
        return len([x for x in s.split() if x == 'ESTABLISHED'])
    except:
        return 0

def get_temperature():
# Returns the temperature in degrees C
    try:
        s = (subprocess.check_output(['/opt/vc/bin/vcgencmd','measure_temp'])).decode()
        return float(s.split('=')[1][:-3])
    except:
        return 0

def get_ipaddress():
# Returns the current IP address
    arg='ip route list'
    p=subprocess.Popen(arg,shell=True,stdout=subprocess.PIPE)
    data = p.communicate()
    split_data = data[0].split()
    ipaddr = (split_data[split_data.index(b'src')+1]).decode()
    return ipaddr

def get_cpu_speed():
# Returns the current CPU speed
    f = os.popen('/opt/vc/bin/vcgencmd get_config arm_freq')
    cpu = f.read()
    return cpu

print('Free RAM: '+str(get_ram()[1])+' ('+str(get_ram()[0])+')')
print('Number of processes: '+str(get_process_count()))
print('Up time: '+get_up_stats()[0])
print('Number of connections: '+str(get_connections()))
print('Temperature in C: ' +str(get_temperature()))
print('IP-address: '+get_ipaddress())
print('CPU speed in MHz: '+str(get_cpu_speed()))
#temperature
import os
import glob
import time
 
# Initialize the GPIO Pins
os.system('modprobe w1-gpio')  # Turns on the GPIO module
os.system('modprobe w1-therm') # Turns on the Temperature module
 
# Finds the correct device file that holds the temperature data
base_dir = '/sys/bus/w1/devices/'
device_folder = glob.glob(base_dir + '28*')[0]
device_file = device_folder + '/w1_slave'
 
# A function that reads the sensors data
def read_temp_raw():
    f = open(device_file, 'r') # Opens the temperature device file
    lines = f.readlines() # Returns the text
    f.close()
    return lines
 
# Convert the value of the sensor into a temperature
def read_temp():
    lines = read_temp_raw() # Read the temperature 'device file'
 
  # While the first line does not contain 'YES', wait for 0.2s
  # and then read the device file again.
    while lines[0].strip()[-3:] != 'YES':
        time.sleep(0.2)
        lines = read_temp_raw()
 
  # Look for the position of the '=' in the second line of the
  # device file.
    equals_pos = lines[1].find('t=')
 
  # If the '=' is found, convert the rest of the line after the
  # '=' into degrees Celsius, then degrees Fahrenheit
    if equals_pos != -1:
        temp_string = lines[1][equals_pos+2:]
        temp_c = float(temp_string) / 1000.0
        temp_f = temp_c * 9.0 / 5.0 + 32.0
        return temp_c, temp_f
 
# Print out the temperature until the program is stopped.
while True:
    try:
        print(read_temp())
        time.sleep(1)
    except KeyboardInterrupt:
        exit()
#test_email        
import smtplib

from_email = 'GMAIL_ADDRESS'
recipients_list = ['RECIPIENT_EMAIL']
cc_list = []
subject = 'Hello'
message = 'This is a test message.'
username = 'GMAIL_USERNAME'
password = 'GOOGLE_APP_PASSWORD'
server = 'smtp.gmail.com:587'

def sendemail(from_addr, to_addr_list, cc_addr_list, subject, message, login, password, smtpserver):
    header = 'From: %s\n' % from_addr
    header += 'To: %s\n' % ','.join(to_addr_list)
    header += 'Cc: %s\n' % ','.join(cc_addr_list)
    header += 'Subject: %s\n\n' % subject
    message = header + message

    server = smtplib.SMTP(smtpserver)
    server.starttls()
    server.login(login, password)
    problems = server.sendmail(from_addr, to_addr_list, message)
    server.quit()

# Send email
sendemail(from_email, recipients_list, cc_list, subject, message, username, password, server)   
#time_example
import time
while True:
    try:
        nowtime = time.time()
        print(time.asctime(time.localtime(nowtime)))
        time.sleep(10)
    except KeyboardInterrupt:
        exit()
